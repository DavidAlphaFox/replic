* Replic

Building a  readline application is  cool, but readline gives  you the
basics  and you  must still  build  a REPL  around it:  loop and  read
commands, catch a =C-c=, a =C-d=,  ask confirmation to quit, print the
general help, help of a command, setup completions, load an init file,
colorize output,...  =replic= does this for you.

You can use =replic= as a ready-to-use executable or as a library.

Using  the executable,  you can  define functions  and variables  in
=~/.replic.lisp= and they will be used as follows:

- an =export='ed function becomes a command in the command line interface. You get
    completion for functions  when your cursor is at  the beginning of
  the prompt.
- an =export='ed variable becomes a variable, which is =set='able in the repl
    (=set= then comes with completion of variables).
- you can define how to complete a function's arguments. Examples below.

=replic= is  also a library with  which you can automatically  build a
REPL and  turn functions you already  have into commands in  the REPL,
with the process described above.

Basic examples below, more to come.

This  is an  attempt at  generalizing what  I did  several times  with
=cl-readline=.

What this is *not*:

- this  is  not a  Lisp  REPL.  See [[https://github.com/koji-kojiro/cl-repl][cl-repl]]  for  that  (itself not  a
  replacement for Slime ;) )
- this is not a shell


=! experimental !=


** Installation

Either download the executable, or clone this repo into =~/quicklisp/local-projects/=.


Then build the executable with =make build=.

: replic -h

#+BEGIN_EXPORT ascii
Available options:
  -h, --help               Print this help and exit.
  -q, --quiet              Do not load the init file.
  -l, --load ARG           Load the given file.
#+END_EXPORT

run:

: ./replic

and

: help
: help help


** The executable and the init file

try =hello <name>= (completion for =hello=) and =goodbye <name>=,
where <name> can be completed from what was given to =hello=.

Your =.replic.lisp= looks like this:

#+BEGIN_SRC lisp
(in-package :replic.user)

(defun duckduckgo (&rest words)
  (format t "searching for ~a...~&" words))

(export '(duckduckgo))
#+END_SRC


*** Set variables

: set *variable*

We kept the "earmuffs" to denote variables.

We get completion on the variables list.


*** Define custom completion for arguments

Write a function or a variable, =export= it.

Associate a function name with a list of completion candidates or a
function, add it to the =*args-completions*= alist:

#+BEGIN_SRC lisp
(push '("goodbye" . *names*) *args-completions*)
(push (cons "hello" #'complete-hello) *args-completions*)
#+END_SRC

=complete-hello= must return a list of strings.

*** Builtin help

You get a built-in =help= command that shows the documentation of
functions and variables:

#+BEGIN_EXPORT ascii
replic > help

Available commands
==================
duckduckgo ... NIL
echo       ... Print the rest of the line. Takes any number of arguments.
hello      ... Takes only one argument. Adds the given name to the global
  `*names*` global variable, used to complete arguments of `goodbye`.
goodbye    ... Says goodbye to name, where `name` should be completed from what was given to `hello`.
help       ... Print the help of all available commands.
reload     ... NIL
set        ... Change this variable.
vim        ... Run vim.

Available variables
===================
*verbose*  ... Example setting.
#+END_EXPORT

Write a preamble and a postamble in =*help-preamble*= and =*help-postamble*=.

You can read the help of a specific command or variable (with completion):

: help help

** Using replic as a library with an existing system

Change the prompt. It defaults to "> ". It can contain ansi colours.

#+BEGIN_SRC lisp
(setf replic:*prompt* (cl-ansi-text:green "replic > "))
#+END_SRC

If  you want  to  have the  base commands  (=help=,  =reload= and  the
example =hello=, =goodbye= and =vim=):

#+BEGIN_SRC lisp
(replic:functions-to-commands :replic.base)
#+END_SRC

Define how to complete your commands:

#+BEGIN_SRC lisp
(push '("goodbye" . *names*) *args-completions*)
(push  (cons "help" #'replic::help-completion) replic:*args-completions*)
#+END_SRC

You can  use a  list, a variable  containing a list  of strings,  or a
function returning a list of strings.

You can set a default completion method for all other commands:

#+BEGIN_SRC lisp
(setf replic:*default-command-completion* #'function-that-returns-list-of-strings)
#+END_SRC

Create the commands from all the exported functions and variables (except "main").

#+BEGIN_SRC lisp
(replic:functions-to-commands :my-package)
#+END_SRC

Start the repl:

: (replic:repl)

That's it. You didn't have to write the REPL.

*** Settings

 - =*prompt*= (str):  the readline prompt.  Defaults to simply  =>Â =. Can
   contain ansi colours (use =cl-ansi-text:green= for example).

 - =*help-preamble*=: text to display at the beginning of the help.

 - =*help-postamble*=: text to display last.

**** Highlighting

We can define a list of words to highlight everytime they are printing
on standard output.

 - =*highlight-words*=: list of words  to capture from standard output
   and highlight (in yellow by default).

 - =*highlight*=: boolean, enable or disable the feature.

- =*highlight-default-color*=: default color  for highlighting. Symbol
  of the =*colors*= list.  Defaults  to =:yellow=. Choices are =:black
  :red   :green   :yellow   :blue   :magenta   :cyan   :white=   (from
  =cl-ansi-text=).

*** Other helpers

- print colored output from markdown or code with pygments:
  =(format-markdown txt :lang "md")=. It outputs text for a console
  display with ansi colours. Needs [[http://pygments.org][pygments]], or
  does nothing.

** Readline settings

The [[https://tiswww.case.edu/php/chet/readline/readline.html][GNU  Readline]] library provides  settings you might  take advantage
of. We can set the settings in the [[https://tiswww.case.edu/php/chet/readline/readline.html#SEC9][readline init file]] (=~/.inputrc= by
default, obeys the =INPUTRC= environment variable).

For example, you can change the *completion behavior*. This:

: TAB: menu-complete

inserts  the  first completion  candidate,  even  if there  are  many,
instead of showing the list of choices under the prompt.

If you prefer *vi mode*:

: set editing-mode vi

etc. See readline's documentation.

** Dev

A  generalization on  =cl-readline=. See  also the  simple [[https://github.com/vindarel/cl-readline-example][cl-readline
example]].  Once you've  built two even basic readline  apps you'll want
to factorize the common parts.

Clone this repo in QL's local projects (=~/quicklisp/local-projects=).

Build the executable:

: make build

*** Develop and test interactively into the console

By starting a swank server in the (real) Lisp repl we can compile code
in our editor  and try instantly in the  terminal, without re-building
the executable. See this [[http://turtleware.eu/posts/cl-charms-crash-course.html][cl-charms  crash course]] for now. Some details
need fixing.


** Resources


- [[https://github.com/vindarel/cl-readline][cl-readline]]
- [[https://github.com/vindarel/cl-readline-example][cl-readline-example]]

Learning:

- [[https://github.com/LispCookbook/cl-cookbook][Common Lisp Cookbook]]
- https://github.com/CodyReichert/awesome-cl#learning-and-tutorials

Getting started:

- [[https://lispcookbook.github.io/cl-cookbook/editor-support.html][Common Lisp editors (Emacs, Portacle, Vim, Lem, Atom, Sublime), notebooks, REPLs]]
- https://lispcookbook.github.io/cl-cookbook/getting-started.html
